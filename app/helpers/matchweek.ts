import { newMatch } from './match';

export function createMatchSchedule(
  teams: TeamDetails['id'][],
  roundRobins = 1,
  avoidGroups?: TeamDetails['id'][][],
): MatchSchedule {
  const teamList = randomizeArray(teams);
  const teams1 = teamList.slice(0, teamList.length / 2);
  const teams2 = teamList.slice(teamList.length / 2, teamList.length);
  let weeks: MatchSchedule = [];
  let rounds = teamList.length - 1; // A team can't play against itself, so the number of rounds is always one less

  /**
   * Expected weeks is further reduced by the number of teams in the avoidGroup (minus the team itself, which is assumed to be in the avoidGroup).
   */
  const expectedWeeks = rounds - (avoidGroups?.[0] ? avoidGroups[0].length - 1 : 0);
  const expectedMatchesPerWeek = teams.length / 2; // Teams should play once per week, so matches per week is always half the number of teams

  while (rounds > 0) {
    const week: Match[] = [];

    for (let i = 0; i < teams1.length; i += 1) {
      const teamA = teams1[i]!;
      const teamB = teams2[i]!;

      const teamsInSameAvoidGroup = avoidGroups?.some(group => group.includes(teamA) && group.includes(teamB));

      if (teamsInSameAvoidGroup) continue;

      const prevWeek = weeks[weeks.length - 1];
      const teamAPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamA);
      const teamBPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamB);

      let homeTeam = teamA;
      let awayTeam = teamB;

      if (prevWeek && teamAPlayedAtHome && !teamBPlayedAtHome) {
        homeTeam = teamB;
        awayTeam = teamA;
      }

      week.push(newMatch(homeTeam, awayTeam));
    }

    weeks.push(randomizeArray(week));

    teams2.push(teams1.pop()!);

    const item = teams1.shift()!;

    teams1.unshift(item, teams2.shift()!);

    rounds -= 1;
  }

  // Remove possible empty weeks generated by avoidGroups
  weeks = weeks.filter(week => week.length > 0);

  // Make sure all weeks have the same number of matches
  let weeksAreUneven = weeks.some(week => week.length !== expectedMatchesPerWeek);

  while (weeksAreUneven) {
    const allMatches = randomizeArray(weeks.flat());
    const newWeeks: MatchSchedule = Array.from({ length: expectedWeeks }, () => []);

    for (const match of allMatches) {
      const matchTeams = [match.homeTeam.id, match.awayTeam.id];

      for (const week of newWeeks) {
        const matchesInWeek = week.filter(m => m).length;

        if (matchesInWeek >= expectedMatchesPerWeek) continue;

        const teamsInWeek = new Set([
          ...week.map(m => m.homeTeam.id),
          ...week.map(m => m.awayTeam.id),
        ]);

        if (!matchTeams.some(t => teamsInWeek.has(t))) {
          week.push(match);
          break;
        }
      }
    }

    if (newWeeks.every(week => week.length === expectedMatchesPerWeek)) {
      weeks = newWeeks;
      weeksAreUneven = false;
    }
  }

  // Round-robin generation
  const robinLength = weeks.length;

  let completedRobins = 1;

  while (completedRobins < roundRobins) {
    weeks.push(
      ...weeks.slice(-1 * robinLength).map(week => (
        week.map(match => newMatch(match.awayTeam.id, match.homeTeam.id))
      )),
    );

    completedRobins += 1;
  }

  return weeks;
}

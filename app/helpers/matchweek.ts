import { newMatch } from './match';

export function getExpectedMatchesPerWeek(numberOfTeams: number): number {
  return numberOfTeams / 2; // Teams should play once per week, so matches per week is always half the number of teams
}

export function getMaxPossibleMatchweeksPerRoundRobin(numberOfTeams: number): number {
  return numberOfTeams - 1; // A team can't play against itself, so the number of matchweeks is always one less
}

export function getExpectedMatchweeksPerRoundRobin(numberOfTeams: number, avoidGroupLength = 0): number {
  // A team is assumed to be in the avoidGroup, so avoidGroupLength is subtracted by one
  return getMaxPossibleMatchweeksPerRoundRobin(numberOfTeams) - Math.max(0, avoidGroupLength - 1);
}

export function createMatchSchedule(payload: {
  teams: TeamDetails['id'][];
  roundRobins?: number;
  avoidGroups?: TeamDetails['id'][][];
}): MatchSchedule {
  const { teams, roundRobins = 1, avoidGroups } = payload;
  const teamList = randomizeArray(teams);
  const teams1 = teamList.slice(0, teamList.length / 2);
  const teams2 = teamList.slice(teamList.length / 2, teamList.length);
  const expectedMatchesPerWeek = getExpectedMatchesPerWeek(teams.length);
  const expectedWeeks = getExpectedMatchweeksPerRoundRobin(teams.length, avoidGroups?.[0]?.length);
  let schedule: MatchSchedule = [];
  let remainingLoops = getMaxPossibleMatchweeksPerRoundRobin(teams.length);

  while (remainingLoops > 0) {
    const week: Match[] = [];

    for (let i = 0; i < teams1.length; i += 1) {
      const teamA = teams1[i]!;
      const teamB = teams2[i]!;

      const teamsInSameAvoidGroup = avoidGroups?.some(group => group.includes(teamA) && group.includes(teamB));

      if (teamsInSameAvoidGroup) continue;

      const prevWeek = schedule[schedule.length - 1];
      const teamAPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamA);
      const teamBPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamB);

      let homeTeam = teamA;
      let awayTeam = teamB;

      if (prevWeek && teamAPlayedAtHome && !teamBPlayedAtHome) {
        homeTeam = teamB;
        awayTeam = teamA;
      }

      week.push(newMatch(homeTeam, awayTeam));
    }

    schedule.push(randomizeArray(week));

    teams2.push(teams1.pop()!);

    const item = teams1.shift()!;

    teams1.unshift(item, teams2.shift()!);

    remainingLoops -= 1;
  }

  // Remove possible empty weeks generated by avoidGroups
  schedule = schedule.filter(week => week.length > 0);

  // Make sure all weeks have the same number of matches
  let weeksAreUneven = schedule.some(week => week.length !== expectedMatchesPerWeek);

  while (weeksAreUneven) {
    const allMatches = randomizeArray(schedule.flat());
    const newSchedule: MatchSchedule = Array.from({ length: expectedWeeks }, () => []);

    for (const match of allMatches) {
      const matchTeams = [match.homeTeam.id, match.awayTeam.id];

      for (const week of newSchedule) {
        const matchesInWeek = week.filter(m => m).length;

        if (matchesInWeek >= expectedMatchesPerWeek) continue;

        const teamsInWeek = new Set([
          ...week.map(m => m.homeTeam.id),
          ...week.map(m => m.awayTeam.id),
        ]);

        if (!matchTeams.some(t => teamsInWeek.has(t))) {
          week.push(match);
          break;
        }
      }
    }

    if (newSchedule.every(week => week.length === expectedMatchesPerWeek)) {
      schedule = newSchedule;
      weeksAreUneven = false;
    }
  }

  // Round-robin generation
  const robinLength = schedule.length;

  let completedRobins = 1;

  while (completedRobins < roundRobins) {
    schedule.push(
      ...schedule.slice(-1 * robinLength).map(week => (
        week.map(match => newMatch(match.awayTeam.id, match.homeTeam.id))
      )),
    );

    completedRobins += 1;
  }

  return schedule;
}

import { newMatch } from './match';
import { getExpectedMatchesPerWeek, getExpectedMatchweeksPerRoundRobin, getMaxPossibleMatchweeksPerRoundRobin } from './matchweek';

interface MatchScheduleParams {
  teams: TeamDetails['id'][];
  roundRobins?: number;
  avoidGroups?: TeamDetails['id'][][];
  weeksToCreate?: number;
}

function addRoundRobins(schedule: MatchSchedule, totalRoundRobins: MatchScheduleParams['roundRobins'] = 1): MatchSchedule {
  const roundRobinWeeksCount = schedule.length;
  const newSchedule = [...schedule];

  let roundRobinsAdded = 1;

  while (roundRobinsAdded < totalRoundRobins) {
    const roundRobin = newSchedule.slice(-1 * roundRobinWeeksCount).map(
      week => week.map(match => newMatch(match.awayTeam.id, match.homeTeam.id)),
    );

    newSchedule.push(...roundRobin);

    roundRobinsAdded += 1;
  }

  return newSchedule;
}

export function generateInitialSchedule(teams: MatchScheduleParams['teams'], avoidGroups?: MatchScheduleParams['avoidGroups']): MatchSchedule {
  if (teams.length % 2 !== 0) {
    throw new Error('Teams array must have an even number of elements');
  }

  const teamsSet = new Set(teams);

  if (teamsSet.size !== teams.length) {
    throw new Error('Teams array must not contain duplicate elements');
  }

  if (avoidGroups && avoidGroups.some(group => group.length % 2 !== 0)) {
    throw new Error('Each avoidGroup must have an even number of elements');
  }

  if (avoidGroups && avoidGroups.some(group => group.length !== avoidGroups[0]?.length)) {
    throw new Error('All avoid groups must have an equal number of elements');
  }

  if (avoidGroups && avoidGroups.flat().some(t => !teamsSet.has(t))) {
    throw new Error('Teams and avoidGroups must have the exact same elements');
  }

  const firstHalfTeams = teams.slice(0, teams.length / 2);
  const secondHalfTeams = teams.slice(teams.length / 2, teams.length);
  const schedule: MatchSchedule = [];
  let remainingMatchweeks = getMaxPossibleMatchweeksPerRoundRobin(teams.length);

  while (remainingMatchweeks > 0) {
    const week: MatchSchedule[number] = [];

    for (let i = 0; i < firstHalfTeams.length; i += 1) {
      const teamA = firstHalfTeams[i]!;
      const teamB = secondHalfTeams[i]!;

      const teamsInSameAvoidGroup = avoidGroups?.some(group => group.includes(teamA) && group.includes(teamB));

      if (teamsInSameAvoidGroup) continue;

      const prevWeek = schedule[schedule.length - 1];
      const teamAPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamA);
      const teamBPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamB);

      let homeTeam = teamA;
      let awayTeam = teamB;

      if (prevWeek && teamAPlayedAtHome && !teamBPlayedAtHome) {
        homeTeam = teamB;
        awayTeam = teamA;
      }

      week.push(newMatch(homeTeam, awayTeam));
    }

    schedule.push(randomizeArray(week));

    secondHalfTeams.push(firstHalfTeams.pop()!);

    const rotatingTeam = firstHalfTeams.shift()!;

    firstHalfTeams.unshift(rotatingTeam, secondHalfTeams.shift()!);

    remainingMatchweeks -= 1;
  }

  return schedule.filter(week => week.length > 0); // Remove possible empty weeks generated by avoidGroups
}

function balanceScheduleWeeks(schedule: MatchSchedule, teamsCount: number, avoidGroupMembersCount?: number): MatchSchedule {
  const expectedMatchesPerWeek = getExpectedMatchesPerWeek(teamsCount);
  const expectedWeeks = getExpectedMatchweeksPerRoundRobin(teamsCount, avoidGroupMembersCount);

  const isBalanced = (value: MatchSchedule) => value.every(week => week.length === expectedMatchesPerWeek);

  if (isBalanced(schedule)) return schedule;

  let rebalancedSchedule = [...schedule];

  while (!isBalanced(rebalancedSchedule)) {
    const allMatches = randomizeArray(schedule.flat());

    rebalancedSchedule = Array.from({ length: expectedWeeks }, () => []);

    for (const match of allMatches) {
      const matchTeams = [match.homeTeam.id, match.awayTeam.id];

      for (const week of rebalancedSchedule) {
        const matchesInWeek = week.filter(m => m).length;

        if (matchesInWeek >= expectedMatchesPerWeek) continue;

        const teamsInWeek = new Set([
          ...week.map(m => m.homeTeam.id),
          ...week.map(m => m.awayTeam.id),
        ]);

        if (!matchTeams.some(t => teamsInWeek.has(t))) {
          week.push(match);
          break;
        }
      }
    }
  }

  return rebalancedSchedule;
}

export function createMatchSchedule(payload: MatchScheduleParams): MatchSchedule {
  const { teams, avoidGroups, weeksToCreate } = payload;

  let schedule = generateInitialSchedule(randomizeArray(teams), avoidGroups);

  schedule = balanceScheduleWeeks(schedule, teams.length, avoidGroups?.[0]?.length);

  schedule = schedule.slice(0, weeksToCreate ?? schedule.length); // Cap weeks to param if provided

  schedule = addRoundRobins(schedule, payload.roundRobins);

  return schedule;
}

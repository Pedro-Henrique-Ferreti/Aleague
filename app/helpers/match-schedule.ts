import { newMatch } from './match';
import { getExpectedMatchesPerWeek, getExpectedMatchweeksPerRoundRobin, getMaxPossibleMatchweeksPerRoundRobin } from './matchweek';

interface MatchScheduleParams {
  teams: TeamDetails['id'][];
  roundRobins?: number;
  avoidGroups?: TeamDetails['id'][][];
  weeksToCreate?: number;
}

export const MAX_EXECUTION_TIME = 10 * 1000;

export function addRoundRobins(schedule: MatchSchedule, totalRoundRobins: MatchScheduleParams['roundRobins'] = 1): MatchSchedule {
  const roundRobinWeeksCount = schedule.length;
  const newSchedule = [...schedule];

  let roundRobinsAdded = 1;

  while (roundRobinsAdded < totalRoundRobins) {
    const roundRobin = newSchedule.slice(-1 * roundRobinWeeksCount).map(
      week => week.map(match => newMatch(match.awayTeam.id, match.homeTeam.id)),
    );

    newSchedule.push(...roundRobin);

    roundRobinsAdded += 1;
  }

  return newSchedule;
}

export function generateInitialSchedule(teams: MatchScheduleParams['teams'], avoidGroups?: MatchScheduleParams['avoidGroups']): MatchSchedule {
  if (teams.length % 2 !== 0) {
    throw new Error('Teams array must have an even number of elements');
  }

  const teamsSet = new Set(teams);

  if (teamsSet.size !== teams.length) {
    throw new Error('Teams array must not contain duplicate elements');
  }

  if (avoidGroups && avoidGroups.some(group => group.length % 2 !== 0)) {
    throw new Error('Each avoidGroup must have an even number of elements');
  }

  if (avoidGroups && avoidGroups.some(group => group.length !== avoidGroups[0]?.length)) {
    throw new Error('All avoid groups must have an equal number of elements');
  }

  if (avoidGroups && avoidGroups.flat().some(t => !teamsSet.has(t))) {
    throw new Error('Teams and avoidGroups must have the exact same elements');
  }

  const firstHalfTeams = teams.slice(0, teams.length / 2);
  const secondHalfTeams = teams.slice(teams.length / 2, teams.length);
  const schedule: MatchSchedule = [];
  let remainingMatchweeks = getMaxPossibleMatchweeksPerRoundRobin(teams.length);

  while (remainingMatchweeks > 0) {
    const week: MatchSchedule[number] = [];

    for (let i = 0; i < firstHalfTeams.length; i += 1) {
      const teamA = firstHalfTeams[i]!;
      const teamB = secondHalfTeams[i]!;

      const teamsInSameAvoidGroup = avoidGroups?.some(group => group.includes(teamA) && group.includes(teamB));

      if (teamsInSameAvoidGroup) continue;

      const prevWeek = schedule[schedule.length - 1];
      const teamAPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamA);
      const teamBPlayedAtHome = prevWeek?.find(m => m.homeTeam.id === teamB);

      let homeTeam = teamA;
      let awayTeam = teamB;

      if (prevWeek && teamAPlayedAtHome && !teamBPlayedAtHome) {
        homeTeam = teamB;
        awayTeam = teamA;
      }

      week.push(newMatch(homeTeam, awayTeam));
    }

    schedule.push(randomizeArray(week));

    secondHalfTeams.push(firstHalfTeams.pop()!);

    const rotatingTeam = firstHalfTeams.shift()!;

    firstHalfTeams.unshift(rotatingTeam, secondHalfTeams.shift()!);

    remainingMatchweeks -= 1;
  }

  return schedule.filter(week => week.length > 0); // Remove possible empty weeks generated by avoidGroups
}

export async function balanceScheduleWeeks(schedule: MatchSchedule, teamsCount: number, avoidGroupMembersCount?: number): Promise<{
  isBalanced: boolean;
  schedule: MatchSchedule;
}> {
  const expectedMatchesPerWeek = getExpectedMatchesPerWeek(teamsCount);
  const expectedWeeks = getExpectedMatchweeksPerRoundRobin(teamsCount, avoidGroupMembersCount);

  const isBalanced = (value: MatchSchedule) => value.every(week => week.length === expectedMatchesPerWeek);

  let rebalancedSchedule = [...schedule];

  const attemptRebalance = (): MatchSchedule => {
    const allMatches = randomizeArray(schedule.flat());
    const result: MatchSchedule = createArray(expectedWeeks, () => [] as Match[]);

    for (const match of allMatches) {
      const matchTeams = [match.homeTeam.id, match.awayTeam.id];

      for (const week of result) {
        const matchesInWeek = week.filter(m => m).length;

        if (matchesInWeek >= expectedMatchesPerWeek) continue;

        const teamsInWeek = new Set([
          ...week.map(m => m.homeTeam.id),
          ...week.map(m => m.awayTeam.id),
        ]);

        if (!matchTeams.some(t => teamsInWeek.has(t))) {
          week.push(match);
          break;
        }
      }
    }

    return result;
  };

  const startTime = new Date().getTime();

  while (!isBalanced(rebalancedSchedule)) {
    if (new Date().getTime() - startTime > MAX_EXECUTION_TIME) break;

    rebalancedSchedule = attemptRebalance();
    await new Promise(resolve => setTimeout(resolve));
  }

  const isBalancedResult = isBalanced(rebalancedSchedule);

  return {
    isBalanced: isBalancedResult,
    schedule: isBalancedResult ? rebalancedSchedule : schedule,
  };
}

export async function createMatchSchedule(payload: MatchScheduleParams): Promise<MatchSchedule> {
  const { teams, avoidGroups, weeksToCreate } = payload;

  let schedule = generateInitialSchedule(randomizeArray(teams), avoidGroups);

  const result = await balanceScheduleWeeks(schedule, teams.length, avoidGroups?.[0]?.length);

  schedule = result.schedule;

  if (result.isBalanced && weeksToCreate) {
    schedule = schedule.slice(0, weeksToCreate);
  }

  schedule = addRoundRobins(schedule, payload.roundRobins);

  return schedule;
}
